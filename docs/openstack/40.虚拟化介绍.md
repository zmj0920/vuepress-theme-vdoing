---
title: 虚拟化介绍
date: 2021-11-22 15:10:53
permalink: /pages/71ad3b/
---

## 一 什么是虚拟化

  虚拟化说白了就是本来是一个完整的资源，切分或者说虚拟成多份，让这多份资源都使用起来，物尽其用，减少了浪费，提高了利用率，省了钱。

  虚拟化（Virtualization）技术最早出现在 20 世纪 60 年代的 IBM 大型机系统，在70年代的 System 370 系列中逐渐流行起来.

在物理硬件之上安装软件：虚拟机监控器（Virtual Machine Monitor，VMM），并且用VMM来控制产生多个的虚拟机（Virtual Machine）实例，每个vm都可以运行独立操作系统及应用软件。  

  虚拟化是一个广义的术语，对于不同的人来说可能意味着不同的东西，这要取决他们所处的环境。在计算机科学领域中，虚拟化代表着对计算资源的抽象，而不仅仅局限于虚拟机的概念。

  比如对物理内存的抽象：产生了虚拟内存技术，使得应用程序认为其自身拥有连续可用的地址空间（Address Space），而实际上，应用程序的代码和数据可能是被分隔成多个碎片页或段），甚至被交换到磁盘、闪存等外部存储器上，即使物理内存不足，应用程序也能顺利执行。

## 二 为何要学习虚拟化

  随着近年多核系统、集群、网格甚至云计算的广泛部署，虚拟化技术在商业应用上的优势日益体现，不仅降低了 IT 成本，而且还增强了系统安全性和可靠性，虚拟化的概念也逐渐深入到人们日常的工作与生活中。

![img](https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif)

```
网格（Grid），在信息学中，网格是一种用于集成或共享地理上分布的各种资源（包括计算机系统、存储系统、通信系统、文件、数据库、程序等），使之成为有机的整体，共同完成各种所需任务的机制。
```

 

  虚拟化是云计算的基础，而我们学习虚拟化的目的之一是为云平台提供云主机，具体的：在一台物理机上产生多台虚拟机（每台vm按照有不同的操作系统），它们共享物理机的cpu，内存，IO硬件资源，但是逻辑上彼此隔离。

## 三 虚拟化技术的分类(了解)

本文讨论的虚拟化技术只针对 x86 平台（含 AMD 64），并假定虚拟机中运行的 Guest OS 也是为 x86 平台设计的。  

　　**一：虚拟化技术主要分为以下几个大类 ：**

1. 平台虚拟化（Platform Virtualization），针对计算机和操作系统的虚拟化，即产生vm。
2. 资源虚拟化（Resource Virtualization），针对特定的系统资源的虚拟化，比如内存虚拟化、存储虚拟化、网络资源虚拟化等。
3. 应用程序虚拟化（Application Virtualization），包括仿真、模拟、解释技术（java虚拟机jvm）等。

  　　**我们通常所说的虚拟化主要是指平台虚拟化技术，通过使用控制程序（Virtual Machine Monitor 或Hypervisor），来创建虚拟机vm。**

  -   Guest OS（客户机操作系统）：虚拟机中运行的操作系统
  -   Host OS（主机操作系统）：运行虚拟机监控器VMM的操作系统，需要注意的是：某些虚拟机监控器VMM可以脱离操作系统直接运行在硬件之上（如 VMWARE 的 ESX 产品）

![](https://cdn.jsdelivr.net/gh/zmj0920/image_store/blog/1036857-20170225163613601-2016342193.png)

 

  **二：平台虚拟化技术又可以细分为如下几个子类：**

　**了解这些分类的关键在于一定要记住：vm是由vmm产生并运行的，然后看下列分类** 

如果把vmm当做小姐，那么vm就相当于嫖客，这个懂了以后下面的概念就很好理解了：

当小姐vmm为嫖客vm提供的是全套服务时，这就是全虚拟化，在嫖客vm的角度看，全套是相当爽的，啥都不用管了，just enjoy it，同样站在嫖客vm的角度去看，嫖的过程中你忘了准备套，怎么办？既然是全套那这个过程必然也包含了，于是小姐vmm去帮你买，这就意味着需要花的时间变长了，严重影响了嫖的效率，要知道时间就是金钱，嘤嘤嘤，说的竟然如此有道理。

 

为了解决上面的问题，足疗店为嫖客准备好了很多硬件设施，比如桌子上放上套，印—度—神—油啥的，对于你这个嫖客vm来说，有了这个特权，没有套这种影响效率的事情，自己直接从桌子上拿一盒最小号码的就行了，不再需要小姐vmm代劳了，这就是硬件辅助虚拟化。

 

嫖了一次你念念不忘，你毅然决然把自己两个肾卖掉，拿着卖肾的钱入股了足疗店，足疗店（硬件）因此为你颁发了终生成就奖和终身vip卡，有了这个vip卡（Hypercall），足疗店（硬件）是你家，你家有啥你就能用啥，这就相当于我们改变不了世界我们改变我们自己，这就是半虚拟化。

 

**1. 全虚拟化（Full Virtualization）**

全虚拟化的核心就在全，‘全’指的是VMM为虚拟机模拟了完整的底层硬件，包括处理器、物理内存、时钟、外设等，这是要飞啊。

这种'全'的特性的牛逼之处在于：原本是为物理硬件设计的操作系统或其它系统软件，完全不做任何修改就可以在虚拟机中运行。

 

然而飞的再高最后也得落地，vm最后还是要与vmm打交道，对于全虚拟化来说， VMM 必须完全并且完整地把自己模拟成硬件，为vm提供全部硬件调用接口，

同时必须模拟特权指令的执行过程，如下例



* 让我们以x86 体系结构下对操作系统进程页表切换的操作(mov pgtable)为例，来介绍VMM把自己完全模拟成硬件是怎么样一种过程：

1.真实的硬件提供了一个特权 CR3 寄存器来实现该接口，操作系统只需执行 "mov pgtable,%%cr3"的 汇编指令即可。

2.VMM 必须按照1中所述，完全地模拟该接口执行的全部过程，但是如果硬件不提供虚拟化的特殊支持，那么这个模拟过程将会十分复杂：
    - a:一般而言VMM 必须运行在最高优先级来完全控制物理主机的系统，而 Guest OS 需要降        级运行，因而不能执行特权操作(如进程页表切换mov pgtable这种特权操作)。
    - b:当 Guest OS 执行前面的特权汇编指令（mov pgtable...）时，物理主机系统产生异常（General Protection Exception），执行控制权重新从 Guest OS 转到 VMM 手中。--->飞的再高也得回到地面
    - c:VMM 先分配一个变量作为影子 CR3 寄存器交给 Guest OS。将 pgtable （进程表）代表的客户机物理地址（Guest Physical Address）填入影子 CR3 寄存器--->让Guest OS以为自己在操作真实的内存。
    - e:然后 VMM 将Guest Os需要操作的pgtable 翻译成物理主机的物理地址（Host Physical Address）并填入物理主机的 CR3 寄存器，最后返回到 Guest OS中。随后 VMM 还将处理复杂的 Guest OS 缺页异常（Page Fault）。


该例子正如下图      

![](https://cdn.jsdelivr.net/gh/zmj0920/image_store/blog/1036857-20170217161847379-1730480406.png)

比较著名的全虚拟化 VMM 有 Microsoft Virtual PC、VMware Workstation、Sun Virtual Box、Parallels Desktop for Mac ,QEMU,KVM。

 

**2. 硬件辅助虚拟化（Hardware-Assisted Virtualization）**

硬件辅助虚拟化主要是为了解决全虚拟化在提供接口的同时必须模拟特权指令的执行过程，是指借助硬件（主要是主机处理器）的支持来实现高效的全虚拟化。例如有了 Intel-VT 技术的支持，Guest OS 和 VMM 的执行环境自动地完全隔离开来，Guest OS 有自己的“全套寄存器”，可以直接运行在最高级别。因此在上面的例子中，Guest OS 能够执行修改页表的汇编指令。Intel-VT 和 AMD-V 是目前 x86 体系结构上可用的两种硬件辅助虚拟化技术。

![](https://cdn.jsdelivr.net/gh/zmj0920/image_store/blog/1036857-20170217162823050-1917863550.png)

 

**3. 半虚拟化（Paravirtualization）**

半虚拟化

这是一种修改 Guest OS 部分访问特权状态的代码以便直接与 VMM 交互的技术。在半虚拟化虚拟机中，部分硬件接口以软件的形式提供给客户机操作系统，这可以通过 Hypercall（VMM 提供给 Guest OS 的直接调用，与系统调用类似）的方式来提供。例如，Guest OS 把切换页表的代码修改为调用 Hypercall 来直接完成修改影子 CR3 寄存器和翻译地址的工作。由于不需要产生额外的异常和模拟部分硬件执行流程，半虚拟化可以大幅度提高性能，比较著名的 VMM 有 Denali、Xen。

![](https://cdn.jsdelivr.net/gh/zmj0920/image_store/blog/1036857-20170217162332175-697668434.png)

 

 

**4. 部分虚拟化（Partial Virtualization）**

VMM 只模拟部分底层硬件，因此客户机操作系统不做修改是无法在虚拟机中运行的，其它程序可能也需要进行修改。在历史上，部分虚拟化是通往全虚拟化道路上的重要里程碑，最早出现在第一代的分时系统 CTSS 和 IBM M44/44X 实验性的分页系统中。

**5. 操作系统级虚拟化（Operating System Level Virtualization）**

在传统操作系统中，所有用户的进程本质上是在同一个操作系统的实例中运行，因此内核或应用程序的缺陷可能影响到其它进程。操作系统级虚拟化是一种在服务器操作系统中使用的轻量级的虚拟化技术，内核通过创建多个虚拟的操作系统实例（内核和库）来隔离不同的进程，不同实例中的进程完全不了解对方的存在。比较著名的有 Solaris Container，FreeBSD Jail 和 OpenVZ 等。 

 

  这种分类并不是绝对的，一个优秀的虚拟化软件往往融合了多项技术。例如 VMware Workstation 是一个著名的全虚拟化的 VMM，但是它使用了一种被称为动态二进制翻译的技术把对特权状态的访问转换成对影子状态的操作，从而避免了低效的 Trap-And-Emulate 的处理方式，这与半虚拟化相似，只不过半虚拟化是静态地修改程序代码。对于这种超虚拟化而言，如果能利用硬件特性，那么虚拟机的管理将会大大简化，同时还能保持较高的性能。

 

**内存虚拟化**

![](https://cdn.jsdelivr.net/gh/zmj0920/image_store/blog/1036857-20170217164526160-2051429943.png)


概念：

MMU是Memory Management Unit的缩写，中文名是内存管理单元，它是中央处理器（CPU）中用来管理虚拟存储器、物理存储器的控制线路，同时也负责虚拟地址映射为物理地址，以及提供硬件机制的内存访问授权，多用户多进程操作系统。

历史：

许多年以前，当人们还在使用DOS或是更古老的操作系统的时候，计算机的内存还非常小，一般都是以K为单位进行计算，相应的，当时的程序规模也不大，所以内存容量虽然小，但还是可以容纳当时的程序。但随着图形界面的兴起还有用户需求的不断增大，应用程序的规模也随之膨胀起来，终于一个难题出现在程序员的面前，那就是应用程序太大以至于内存容纳不下该程序，通常解决的办法是把程序分割成许多称为覆盖块（overlay）的片段。覆盖块0首先运行，结束时他将调用另一个覆盖块。虽然覆盖块的交换是由OS完成的，但是必须先由程序员把程序先进行分割，这是一个费时费力的工作，而且相当枯燥。人们必须找到更好的办法从根本上解决这个问题。不久人们找到了一个办法，这就是虚拟存储器(virtual memory).虚拟存储器的基本思想是程序，数据，堆栈的总的大小可以超过物理存储器的大小，操作系统把当前使用的部分保留在内存中，而把其他未被使用的部分保存在磁盘上。比如对一个16MB的程序和一个内存只有4MB的机器，操作系统通过选择，可以决定各个时刻将哪4M的内容保留在内存中，并在需要时在内存和磁盘间交换程序片段，这样就可以把这个16M的程序运行在一个只具有4M内存机器上了。而这个16M的程序在运行前不必由程序员进行分割。

MMU的功能是：将线性地址映射为物理地址

现代的多用户多进程操作系统，需要MMU，才能达到每个用户进程都拥有自己独立的地址空间的目标。使用MMU,操作系统划分出一段地址区域，在这块地址区域中，每个进程看到的内容都不一定一样。例如MICROSOFT WINDOWS操作系统将地址范围4M-2G划分为用户地址空间，进程A在地址0X400000（4M）映射了可执行文件，进程B同样在地址0X400000（4M）映射了可执行文件，如果A进程读地址0X400000，读到的是A的可执行文件映射到RAM的内容，而进程B读取地址0X400000时，则读到的是B的可执行文件映射到RAM的内容。



  上图中的左半部分是正常情况下内存的使用情况，线性地址到物理地址的一个转换，通常应用程序使用的内存地址是线性地址，需要通过[MMU](http://baike.baidu.com/link?url=PQRdBo22ghs7cMyMXhGrnOPREcZ0yaq6QbSUcpg_6Z1vuelq-On04QzYcShv_i73T4scue2IWht0e-Mu_95-Nq)地址转换的一个硬件来实现线性地址到物理地址的一个转换。

  上图的右半部分是虚拟化情况下内存是如何实现线性地址到物理地址的转换,虚拟机中的OS获得是有Host OS分配的[线性地址](http://baike.baidu.com/item/线性地址/9013682?search=new)，Guest OS中的应用程序获取的是相对于Guest os来说的线性地址，那么对于这个线性地址来说最终只能转换成线性地址，无法转换成正在的物理地址，虚拟化中就提供了一个虚拟的MMU直接将Guest OS中的线性地址直接转换成真正的物理地址，但是这个虚拟的MMU毕竟是虚拟出来的没有真实的硬件MMU性能好而且虚拟MMU的开发也很复杂，每一个Guest都要有一个MMU，这对内存消耗太大。对于这种技术我们称作是影子页表技术。

  此后Intel开创了EPT(Extended Page Tables)技术,相对于影子页表技术来说EPT技术降低了内存虚拟化的难度，EPT技术是直接在硬件上实现了Guest OS中的线性地址到Guest OS中的物理地址再到Host OS中的物理地址的两次转换。

**IO的虚拟化**

![](https://cdn.jsdelivr.net/gh/zmj0920/image_store/blog/1036857-20170217164717722-1116167814.png)

**最左边IO虚拟化的使用的是仿真技术:**

  我们将要着重研究的kvm虚拟化就引用了这种技术   

  仿真(emulation)是一个完全通过软件程序来模拟硬件的技术。早期虚拟化都才采用这种方案来虚拟网络设备。常见仿真软件有QEMU、VMware WorkStation、VirtualBox。Emulation网

**中间的IO虚拟化是Para-virtualization:**

  Para-virtualization又称半虚拟化，最早由Citrix的Xen提出使用。在半虚拟化模型中，物理硬件资源统一由 Hypervisor管理，由Hypervisor提供资源调用接口。虚拟子机通过特定的调用接口与Hypervisor通信，然后完整的对I/O资源进行控制操作.

**最右边的是直接IO**

  Hypervisor将一个PCI设备(可以是网卡、USB、光驱)直接分配给指定虚拟子机单独访问。为了安全和稳定性考虑，，pass-through使用通常结合intel VT-D(AMD也有类似技术)来使用，通过iommu保证虚拟子机之间内存访问不冲突。这种技术在VMware上叫VMDirectPath I/O，其他方案中没有找到相关专门名词。

**网络虚拟化** 

我们将在介绍neutron时详细介绍网络虚拟化 

 

参考资料：<http://www.ibm.com/developerworks/cn/linux/l-cn-vt/index.html>
