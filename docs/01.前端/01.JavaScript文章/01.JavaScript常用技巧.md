---
title: JavaScript常用技巧
date: 2019-12-25 14:27:01
permalink: /pages/8143cc480faccdd
categories: 
  - 前端
  - JavaScript文章
article: false
---
# JavaScript常用技巧

      

作为程序猿的我们，写代码同样也需要大量的写作技巧。一份良好的代码能让人耳目一新，让人容易理解，
让人舒服自然，下面为大家带来经常使用到的一些JS开发技巧，希望能让你写出耳目一新、容易理解、舒服自然的代码。



## String 字符串技巧


### 对比时间

```js
const time1 = "2019-02-14 21:00:00";
const time2 = "2019-05-01 09:00:00";
const overtime = time1 > time2;
// overtime => false
```

### 获取日期天数

```js
const dayOfYear = date =>
  Math.floor((date - new Date(date.getFullYear(), 0, 0)) / 1000 / 60 / 60 / 24);

dayOfYear(new Date()); 
```



### 返回日期区间的天数


```js
const getDaysDiffBetweenDates = (dateInitial, dateFinal) =>
  (dateFinal - dateInitial) / (1000 * 3600 * 24);
  
getDaysDiffBetweenDates(new Date('2019-01-01'), new Date('2019-10-14')); // 286
```

### 检查是否在某日期后

```js
const isAfterDate = (dateA, dateB) => dateA > dateB;

isAfterDate(new Date(2010, 10, 21), new Date(2010, 10, 20)); // true
```

### 检查是否在某日期前

```js
const isBeforeDate = (dateA, dateB) => dateA < dateB;

isBeforeDate(new Date(2010, 10, 20), new Date(2010, 10, 21)); // true
```

### 获取明天的字符串格式时间

```js
const tomorrow = () => {
  let t = new Date();
  t.setDate(t.getDate() + 1);
  return t.toISOString().split('T')[0];
};

tomorrow(); // 2019-10-15 (如果明天是2019-10-15)
```



### 统计相同字符出现次数

```js
var str = 'aaabbbccc66aabbc6';

var strInfo = str.split('').reduce((p, c) => (p[c]++ || (p[c] = 1), p), {});

console.log(strInfo); // {6: 3, a: 5, b: 5, c: 4}
```

## Number 数值技巧


### 取整

* 代替正数的Math.floor()，代替负数的Math.ceil()

```js
const num1 = ~~ 1.69; //1
const num2 = 1.69 | 0; //1
const num3 = 1.69 >> 0; //1
```


### 数字开头补零

```js
const FillZero = (num, len) => num.toString().padStart(len, "0");
const num = FillZero(169, 5);
// num => "00169"
```

### 转数值

* 只对null、""、false、数值字符串有效

```js
        const num1 = +null; //0
        const num2 = +"";   //0
        const num3 = +false;//0
        const num4 = +"169";//169
```



### 判断奇偶

```js
const OddEven = num => !!(num & 1) ? "odd" : "even";
const num = OddEven(2);
// num => "even"
```



### 取最小最大值

```js
const arr = [0, 1, 2];
const min = Math.min(...arr);
const max = Math.max(...arr);
// min max => 0 2
```


### 生成范围随机数

```js
const RandomNum = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
const num = RandomNum(1, 10);
```


## Boolean 布尔值技巧

### 短路运算符

我们知道逻辑与&&与逻辑或||是短路运算符，短路运算符就是从左到右的运算中前者满足要求，就不再执行后者了；

```js
        const d = 2;
        const a = d && 1; // d 为false  a值取 false
        const b = d || 1; // d 为 true b取值 true d 为 false b取值1
        const c = !d; // 取假赋值：单个表达式转换为true则返回false，否则返回true
        console.log(a) //1
        console.log(b)//2
        console.log(c)//false
```

### 判断数据类型

* 可判断类型：undefined、null、string、number、boolean、array、object、symbol、date、regexp、function、asyncfunction、arguments、set、map、weakset、weakmap



```js
Object.prototype.toString.call('string');       //"[object String]"
Object.prototype.toString.call(1111);           //"[object Number]"
Object.prototype.toString.call(true);           //"[object Boolean]"
Object.prototype.toString.call(null);           //"[object Null]"
Object.prototype.toString.call(undefined);      //"[object Undefined]"
Object.prototype.toString.call(Symbol('111'));  //"[object Symbol]"
Object.prototype.toString.call({});             //"[object Object]"
function DataType(tgt, type) {
    const dataType = Object.prototype.toString.call(tgt).replace(/\[object /g, "").replace(/\]/g, "").toLowerCase();
    return type ? dataType === type : dataType;
}
DataType("young"); // "string"
DataType(20190214); // "number"
DataType(true); // "boolean"
DataType([], "array"); // true
DataType({}, "array"); // false

 const flag = DataType(obj, "object") && !Object.keys(obj).length;
 console.log(flag)
// flag => true
```

### 满足条件时执行

```js
const flagA = true; // 条件A
const flagB = false; // 条件B
(flagA || flagB) && Func(); // 满足A或B时执行
(flagA || !flagB) && Func(); // 满足A或不满足B时执行
flagA && flagB && Func(); // 同时满足A和B时执行
flagA && !flagB && Func(); // 满足A且不满足B时执行
```



### 为非假值时执行

```js
const flag = false; // undefined、null、""、0、false、NaN
!flag && Func();
```


### 数组不为空时执行

```js
const arr = [0, 1, 2];
arr.length && Func();
```

### 对象不为空时执行

```js
const obj = { a: 0, b: 1, c: 2 };
Object.keys(obj).length && Func();
```


### 函数退出代替条件分支退出

```js
if (flag) {
    Func();
    return false;
}
// 换成
if (flag) {
    return Func();
}
```


### switch/case使用区间

```js
const age = 26;
switch (true) {
    case isNaN(age):
        console.log("not a number");
        break;
    case (age < 18):
        console.log("under age");
        break;
    case (age >= 18):
        console.log("adult");
        break;
    default:
        console.log("please set your age");
        break;
}
```

### 对象不为空时执行

```js
const obj = { a: 0, b: 1, c: 2 };
Object.keys(obj).length && Func();
```


## Array 数组技巧


### 克隆数组

```js
const _arr = [0, 1, 2];
const arr = [..._arr];
// arr => [0, 1, 2]
```


### 合并数组

```js
const arr1 = [0, 1, 2];
const arr2 = [3, 4, 5];
const arr = [...arr1, ...arr2];
// arr => [0, 1, 2, 3, 4, 5];
```


### 混淆数组

```js
const arr = [0, 1, 2, 3, 4, 5].slice().sort(() => Math.random() - .5);
// arr => [3, 4, 0, 5, 1, 2]
```


### 清空数组

```js
const arr = [0, 1, 2];
arr.length = 0;
// arr => []
```


### 截断数组

```js
const arr = [0, 1, 2];
arr.length = 2;
// arr => [0, 1]
```


### 交换赋值

```js
let a = 0;
let b = 1;
[a, b] = [b, a];
// a b => 1 0
```


### 过滤数组中的所有假值

* 空值：undefined、null、""、0、false、NaN

```js
const arr = [undefined, null, "", 0, false, NaN, 1, 2].filter(Boolean);
// arr => [1, 2]
```


### 异步累计

```js
async function Func(deps) {
    return deps.reduce(async(t, v) => {
        const dep = await t;
        const version = await Todo(v);
        dep[v] = version;
        return dep;
    }, Promise.resolve({}));
}
const result = await Func(); // 需在async包围下使用
```

### 数组首部插入成员

```js
let arr = [1, 2]; // 以下方法任选一种
arr.unshift(0);
arr = [0].concat(arr);
arr = [0, ...arr];
// arr => [0, 1, 2]
```

### 数组尾部插入成员

```js
let arr = [0, 1]; // 以下方法任选一种
arr.push(2);
arr.concat(2);
arr[arr.length] = 2;
arr = [...arr, 2];
// arr => [0, 1, 2]
```

### 统计数组成员个数

```js
const arr = [0, 1, 1, 2, 2, 2];
const count = arr.reduce((t, c) => {
    t[c] = t[c] ? ++ t[c] : 1;
    return t;
}, {});
// count => { 0: 1, 1: 2, 2: 3 }
```
### 解构数组成员嵌套

```js
const arr = [0, 1, [2, 3, [4, 5]]];
const [a, b, [c, d, [e, f]]] = arr;
// a b c d e f => 0 1 2 3 4 5
```


### 解构数组成员别名

```js
const arr = [0, 1, 2];
const { 0: a, 1: b, 2: c } = arr;
// a b c => 0 1 2
```


### 解构数组成员默认值

```js
const arr = [0, 1, 2];
const [a, b, c = 3, d = 4] = arr;
// a b c d => 0 1 2 4
```

### 获取随机数组成员

```js
const arr = [0, 1, 2, 3, 4, 5];
const randomItem = arr[Math.floor(Math.random() * arr.length)];
// randomItem => 1
```



### 创建指定长度数组

```js
const arr = [...new Array(3).keys()];
// arr => [0, 1, 2]
```


### 创建指定长度且值相等的数组

```js
const arr = new Array(3).fill(0);
// arr => [0, 0, 0]
```


### reduce代替map和filter

```js
const _arr = [0, 1, 2];

// map
const arr = _arr.map(v => v * 2);
const arr = _arr.reduce((t, c) => {
    t.push(c * 2);
    return t;
}, []);
// arr => [0, 2, 4]

// filter
const arr = _arr.filter(v => v > 0);
const arr = _arr.reduce((t, c) => {
    c > 0 && t.push(c);
    return t;
}, []);
// arr => [1, 2]

// map和filter
const arr = _arr.map(v => v * 2).filter(v => v > 2);
const arr = _arr.reduce((t, c) => {
    c = c * 2;
    c > 2 && t.push(c);
    return t;
}, []);
// arr => [4]
```

### 数组去重



> includes

```js
var arr=[1,1,1,2,2,3,4,5,6];
var newArr=[];
for(var i in arr){
    //包含则返回 true，否则返回false
    if(!newArr.includes(arr[i])){
        newArr.push(arr[i])
    }
}
//console.log(newArr) 
```

> indexOf

```js
var arr=[1,1,1,2,2,3,4,5,6];
var newArr = [];
for (var i = 0; i < arr.length; i++) {
    //不存在时返回-1
    if (newArr.indexOf(arr[i]) === -1) {
        newArr.push(arr[i])
    }
}
```

> Set

```js

let set=new Set(arr);
let newArr=[...set];
或者
let newArr=Array.from(set);
```

> reduce

```js
let arr=[1,2,3,4,5,6,5,4,3,2,4,3,5];
let result=arr.reduce((prev,cur,index,arr)=>{
    prev.indexOf(cur)==-1?prev.push(cur):prev;
    return prev;
},[])
console.log(result);// [1, 2, 3, 4, 5, 6]

```

### Array原型上添加一个去重的函数（返回新数组）

> indexOf

```js 
if (!Array.prototype.unique) {
    Array.prototype.unique = function () {
        let arr = [];
        for (let i = 0; i < this.length; i++) {
            //不存在返回-1
            if (arr.indexOf(this[i]) === -1) {
                arr.push(this[i])
            }
        }
        // console.log(arr);
        return arr;
    }
}
let arr=[1,2,3,4,5,6,5,4,3,2,4,3,5];
console.log(arr.unique()) 
```

> includes

```js
if (!Array.prototype.unique) {
    Array.prototype.unique = function () {
        for (let i = 0; i < this.length; i++) {
            //包含则返回 true，否则返回false
            if (!arr.includes(this[i])) {
                arr.push(this[i]);
            }
        }
        return arr;
    }
}
```

> includes

```js
if (!Array.prototype.unique) {
    Array.prototype.unique = function () {
       let arr=new Set(this)

        return [...arr];
    }
}
```



## Object 对象技巧


### json转化成树结构

根据每项的parent_id，生成具体树形结构的对象

```js
 const tree = (items, id = null, link = 'parent_id') =>
        items
          .filter(item => item[link] === id)
          .map(item => ({ ...item, children: tree(items, item.id) }));
const comments = [
  { id: 1, parent_id: null },
  { id: 2, parent_id: 1 },
  { id: 3, parent_id: 1 },
  { id: 4, parent_id: 2 },
  { id: 5, parent_id: 4 }
];
const newtree = tree(comments);
        //转化后
[
    {
        "id":1,
        "parent_id":null,
        "children":[
            {
                "id":2,
                "parent_id":1,
                "children":[
                    {
                        "id":4,
                        "parent_id":2,
                        "children":[
                            {
                                "id":5,
                                "parent_id":4,
                                "children":[

                                ]
                            }
                        ]
                    }
                ]
            },
            {
                "id":3,
                "parent_id":1,
                "children":[

                ]
            }
        ]
    }
]        

```


### Object.keys()

Object.keys 返回一个所有元素为字符串的数组，其元素来自于从给定的object上面可直接枚举的属性。这些属性的顺序与手动遍历该对象属性时的一致。


```js
let obj = {
    name: 'haha', 
    age: 20,
    showName:  function () {}
}
Object.keys(obj)   //['name','age','showName']
```

### Object.values()

Object.values()方法返回一个给定对象自身的所有可枚举属性值的数组，值的顺序与使用for...in循环的顺序相同 ( 区别在于 for-in 循环枚举原型链中的属性 )。

```js
let obj = {
    name: 'haha', 
    age: 20,
    showName:  function () {}
}
Object.values(obj)   //['haha','20', f]
```



### Object.entries()

Object.entries()方法返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 for...in 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环也枚举原型链中的属性）。

```js
const obj = { a: 5, b: 7, c: 9 };
for (const [key, value] of Object.entries(obj)) {
  console.log(`${key} ${value}`); // "a 5", "b 7", "c 9"
}
// 或者
Object.entries(obj).forEach(([key, value]) => {
console.log(`${key} ${value}`); // "a 5", "b 7", "c 9"
});
```

### 浅拷贝 Object.assign

Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。

```js
let a = {
    name: "muyiy",
    age: 18
}
let b = {
    b1: Symbol("muyiy"),
    b2: null,
    b3: undefined
}
let c = Object.assign(a, b);
console.log(c);
// {
// 	name: "muyiy",
//  age: 18,
// 	b1: Symbol(muyiy),
// 	b2: null,
// 	b3: undefined
// } 
console.log(a === c);
// true
```



### 克隆对象

```js
const _obj = { a: 0, b: 1, c: 2 }; // 以下方法任选一种
const obj = { ..._obj };
const obj = JSON.parse(JSON.stringify(_obj));
// obj => { a: 0, b: 1, c: 2 }
```

### 合并对象

```js
const obj1 = { a: 0, b: 1, c: 2 };
const obj2 = { c: 3, d: 4, e: 5 };
const obj = { ...obj1, ...obj2 };
// obj => { a: 0, b: 1, c: 3, d: 4, e: 5 }
```
### 对象字面量

* 获取环境变量时必用此方法
 
```js
const env = "prod";
const link = {
    dev: "Development Address",
    test: "Testing Address",
    prod: "Production Address"
}[env];
// link => "Production Address"
```
### 对象变量属性

```js
const flag = false;
const obj = {
    a: 0,
    b: 1,
    [flag ? "c" : "d"]: 2
};
// obj => { a: 0, b: 1, d: 2 }
```

### 创建纯空对象

```js
const obj = Object.create(null);
Object.prototype.a = 0;
// obj => {}
```

### 删除对象无用属性

```js
const obj = { a: 0, b: 1, c: 2 }; // 只想拿b和c
const { a, ...rest } = obj;
// rest => { b: 1, c: 2 }
```

### 解构对象属性嵌套

```js
const obj = { a: 0, b: 1, c: { d: 2, e: 3 } };
const { c: { d, e } } = obj;
// d e => 2 3
```

### 解构对象属性别名

```js
const obj = { a: 0, b: 1, c: 2 };
const { a, b: d, c: e } = obj;
// a d e => 0 1 2
```


### 解构对象属性默认值

```js
const obj = { a: 0, b: 1, c: 2 };
const { a, b = 2, d = 3 } = obj;
// a b d => 0 1 3

```



## Function 函数技巧



### 函数自执行

```js
const Func = function() {}(); // 常用

(function() {})(); // 常用
(function() {}()); // 常用
[function() {}()];

+ function() {}();
- function() {}();
~ function() {}();
! function() {}();

new function() {};
new function() {}();
void function() {}();
typeof function() {}();
delete function() {}();

1, function() {}();
1 ^ function() {}();
1 > function() {}();
```

### 隐式返回值

*只能用于单语句返回值箭头函数，如果返回值是对象必须使用()包住

```js
const Func = function(name) {
    return "I Love " + name;
};
// 换成
const Func = name => "I Love " + name;
```

### 一次性函数

* 适用于运行一些只需执行一次的初始化代码

```js
function Func() {
    console.log("x");
    Func = function() {
        console.log("y");
    }
}
```

### 惰性载入函数

 * 函数内判断分支较多较复杂时可大大节约资源开销

```js
function Func() {
    if (a === b) {
        console.log("x");
    } else {
        console.log("y");
    }
}
// 换成
function Func() {
    if (a === b) {
        Func = function() {
            console.log("x");
        }
    } else {
        Func = function() {
            console.log("y");
        }
    }
    return Func();
}
```

### 检测非空参数

```js
function IsRequired() {
    throw new Error("param is required");
}
function Func(name = IsRequired()) {
    console.log("I Love " + name);
}
Func(); // "param is required"
Func("You"); // "I Love You"

```

### 字符串创建函数

```js
const Func = new Function("name", "console.log(\"I Love \" + name)");
```

### 优雅处理错误信息

```js
try {
    Func();
} catch (e) {
    location.href = "https://stackoverflow.com/search?q=[js]+" + e.message;
}
```

### 处理Async/Await参数

```js
function AsyncTo(promise) {
    return promise.then(data => [null, data]).catch(err => [err]);
}
const [err, res] = await AsyncTo(Func());

```

### 优雅处理多个函数返回值

```js
function Func() {
    return Promise.all([
        fetch("/user"),
        fetch("/comment")
    ]);
}
const [user, comment] = await Func(); // 需在async包围下使用
```

## DOM DOM技巧

### 显示全部DOM边框

* 调试页面元素边界时使用

```js
[].forEach.call($$("*"), dom => {
    dom.style.outline = "1px solid #" + (~~(Math.random() * (1 << 24))).toString(16);
});
```

### 自适应页面

 * 页面基于一张设计图但需做多款机型自适应，元素尺寸使用rem进行设置

```js
function AutoResponse(width = 750) {
    const target = document.documentElement;
    target.clientWidth >= 600
        ? (target.style.fontSize = "80px")
        : (target.style.fontSize = target.clientWidth / width * 100 + "px");
}
```

### 过滤XSS

```js
function FilterXss(content) {
    let elem = document.createElement("div");
    elem.innerText = content;
    const result = elem.innerHTML;
    elem = null;
    return result;
}
```



