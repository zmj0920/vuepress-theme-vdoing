---
title: JavaScropt基础介绍
date: 2021-05-22 18:51:22
permalink: /pages/cbc913/
---

JavaScript（简称“JS”） 是一种具有函数优先的轻量级，解释型或即时编译型的编程语言，JavaScript 基于原型编程、多范式的动态脚本语言，并且支持面向对象、命令式和声明式（如函数式编程）风格，作为前端开发者是必须掌握的一门语言这篇文章介绍了 JS 的各种基础知识和应用场景的实例，是一片很好的基础学习文档

## 对象

[2]: http://www.jslint.com/
[5]: http://prototypejs.org/
[6]: https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/forEach
[7]: http://en.wikipedia.org/wiki/Backport
[8]: http://en.wikipedia.org/wiki/Inlining
[9]: https://developer.mozilla.org/en/JavaScript/Strict_mode
[10]: http://net.tutsplus.com/tutorials/javascript-ajax/quick-tip-javascript-hoisting-explained/
### 对象使用

JavaScript 中所有变量都可以当作对象使用，除了两个例外 [`null`] 和 [`undefined`]。

```js
false.toString(); // 'false'
[1, 2, 3].toString(); // '1,2,3'

function Foo() {}
Foo.bar = 1;
Foo.bar; // 1
```

一个常见的误解是数字的字面值（literal）不能当作对象使用。这是因为 JavaScript 解析器的一个错误，
它试图将*点操作符*解析为浮点数字面值的一部分。

    2.toString(); // 出错：SyntaxError

有很多变通方法可以让数字的字面值看起来像对象。

    2..toString(); // 第二个点号可以正常解析
    2 .toString(); // 注意点号前面的空格
    (2).toString(); // 2先被计算

### 数据类型

JavaScript 的对象可以作为[_哈希表_]使用，主要用来保存命名的键与值的对应关系。

使用对象的字面语法 - `{}` - 可以创建一个简单对象。这个新创建的对象从 `Object.prototype`
[继承]下来，没有任何[自定义属性]。

```js
    var foo = {}; // 一个空对象
    // 一个新对象，拥有一个值为12的自定义属性'test'
    var bar = {test: 12};
```

### 访问属性

有两种方式来访问对象的属性，点操作符和中括号操作符。
```js
    var foo = {name: 'kitten'}
    foo.name; // kitten
    foo['name']; // kitten

    var get = 'name';
    foo[get]; // kitten

    foo.1234; // SyntaxError
    foo['1234']; // works
```
两种语法是等价的，但是中括号操作符在下面两种情况下依然有效

- 动态设置属性
- 属性名不是一个有效的变量名（比如属性名中包含空格，或者属性名是 JS 的关键词）

> 在 [JSLint][2] 语法检测工具中，点操作符是推荐做法。

### 删除属性

删除属性的唯一方法是使用 `delete` 操作符；设置属性为 `undefined` 或者 `null` 并不能真正的删除属性，
而**仅仅**是移除了属性和值的关联。
```js
    var obj = {
        bar: 1,
        foo: 2,
        baz: 3
    };
    obj.bar = undefined;
    obj.foo = null;
    delete obj.baz;

    for(var i in obj) {
        if (obj.hasOwnProperty(i)) {
            console.log(i, '' + obj[i]);
        }
    }
```
上面的输出结果有 `bar undefined` 和 `foo null` - 只有 `baz` 被真正的删除了，所以从输出结果中消失。

### 属性名使用
```js
    var test = {
        'case': 'I am a keyword so I must be notated as a string',
        delete: 'I am a keyword too so me' // 出错：SyntaxError
    };
```
对象的属性名可以使用字符串或者普通字符声明。但是由于 JavaScript 解析器的另一个错误设计，
上面的第二种声明方式在 ECMAScript 5 之前会抛出 `SyntaxError` 的错误。

这个错误的原因是 `delete` 是 JavaScript 语言的一个*关键词*；因此为了在更低版本的 JavaScript 引擎下也能正常运行，
必须使用*字符串字面值*声明方式。

## 原型

JavaScript 不包含传统的类继承模型，而是使用 _prototype_ 原型模型。

虽然这经常被当作是 JavaScript 的缺点被提及，其实基于原型的继承模型比传统的类继承还要强大。
例如，很容易通过原型继承实现传统的类继承模型，但是反过来，通过传统的类继承模型来实现原型继承模型就困难得多。
(It is for example fairly trivial to build a classic model on top of it, while the
other way around is a far more difficult task.)

由于 JavaScript 是唯一一个被广泛使用的基于原型继承的语言，所以理解两种继承模式的差异是需要一定时间的。

第一个不同之处在于 JavaScript 使用*原型链*的继承方式。

> **注意:** 简单的使用 `Bar.prototype = Foo.prototype` 将会导致两个对象共享**相同**的原型。
> 因此，改变任意一个对象的原型都会影响到另一个对象的原型，在大多数情况下这不是希望的结果。
```js
    function Foo() {
        this.value = 42;
    }
    Foo.prototype = {
        method: function() {}
    };

    function Bar() {}

    // 设置 Bar 的 prototype 属性为 Foo 的实例对象
    Bar.prototype = new Foo();
    Bar.prototype.foo = 'Hello World';

    // 修正 Bar.prototype.constructor 为 Bar 本身
    Bar.prototype.constructor = Bar;

    var test = new Bar(); // 创建Bar的一个新实例

    // 原型链
    test [Bar的实例]
        Bar.prototype [Foo的实例]
            { foo: 'Hello World', value: 42 }
            Foo.prototype
                {method: ...};
                Object.prototype
                    {toString: ... /* etc. */};
```
上面的例子中，`test` 对象从 `Bar.prototype` 和 `Foo.prototype` 继承下来；因此，
它能访问 `Foo` 的原型方法 `method`。同时，它也能够访问**那个**定义在原型上的 `Foo` 实例属性 `value`。
需要注意的是 `new Bar()` **不会**创造出一个新的 `Foo` 实例，而是
重复使用它原型上的那个实例；因此，所有的 `Bar` 实例都会共享**相同**的 `value` 属性。

> **注意:** **不要**使用 `Bar.prototype = Foo`，因为这不会指向 `Foo` 的原型，而是指向函数 `Foo`。
> 因此原型链将会回溯到 `Function.prototype` 而不是 `Foo.prototype`，因此 `method` 将不会在 Bar 的原型链上。

### 原型属性

当查找一个对象的属性时，JavaScript 会**向上**遍历原型链，直到找到给定名称的属性为止。

到查找到达原型链的顶部 - 也就是 `Object.prototype` - 但是仍然没有找到指定的属性，就会返回 [undefined]。

当原型属性用来创建原型链时，可以把**任何**类型的值赋给它（prototype）。
然而将原子类型（primitives）赋给 prototype 的操作将会被忽略。
```js
    function Foo() {}
    Foo.prototype = 1; // 无效
```
而将对象赋值给 prototype，正如上面的例子所示，将会动态的创建原型链。

### 性能

如果一个属性在原型链的上端，则对于查找时间将带来不利影响。注意，试图获取一个不存在的属性将会遍历整个原型链。

并且，当使用 [`for in`] 循环遍历对象的属性时，原型链上的**所有**属性都将被访问。

### 扩展内置类型的原型

扩展 `Object.prototype` 或者其他内置类型的原型对象，作为一个错误特性，经常被使用。

这种技术被称之为 [monkey patching] 并且会破坏*封装*。虽然它被广泛的应用到一些 JavaScript 类库中比如 [Prototype][5],
但是我仍然不赞同为内置类型添加一些*非标准*的函数。

扩展内置类型的**唯一**理由是为了和新的 JavaScript 保持一致，比如 [`Array.forEach`][6]。

> 这是编程领域常用的一种方式，称之为 [Backport][7]，也就是将新的补丁添加到老版本中。

> 总结

在写复杂的 JavaScript 应用之前，充分理解原型链继承的工作方式是每个 JavaScript 程序员**必修**的功课。
要提防原型链过长带来的性能问题，并知道如何通过缩短原型链来提高性能。
更进一步，绝对**不要**扩展内置类型的原型，除非是为了和新的 JavaScript 引擎兼容。

### hasOwnProperty 函数

为了判断一个对象是否包含*自定义*属性而*不是*[原型链]上的属性，
我们需要使用继承自 `Object.prototype` 的 `hasOwnProperty` 方法。

> **注意:** 通过判断一个属性是否 `undefined` 是**不够**的。
> 因为一个属性可能确实存在，只不过它的值被设置为 `undefined`。

`hasOwnProperty` 是 JavaScript 中唯一一个处理属性但是**不**查找原型链的函数。
```js
    // 修改 Object.prototype
    Object.prototype.bar = 1;
    var foo = {goo: undefined};

    foo.bar; // 1
    'bar' in foo; // true

    foo.hasOwnProperty('bar'); // false
    foo.hasOwnProperty('goo'); // true
```
JavaScript **不会**保护 `hasOwnProperty` 被非法占用，因此如果一个对象碰巧存在这个属性，
就需要使用*外部*的 `hasOwnProperty` 函数来获取正确的结果。
```js
    var foo = {
        hasOwnProperty: function() {
            return false;
        },
        bar: 'Here be dragons'
    };

    foo.hasOwnProperty('bar'); // 总是返回 false

    // 使用其它对象的 hasOwnProperty，并将其上下文设置为 foo
    ({}).hasOwnProperty.call(foo, 'bar'); // true
```
> 结论

当检查对象上某个属性是否存在时，`hasOwnProperty` 是**唯一**可用的方法。
同时在使用 [`for in` loop] 遍历对象时，推荐**总是**使用 `hasOwnProperty` 方法，
这将会避免[原型]对象扩展带来的干扰。

### for in 循环

和 `in` 操作符一样，`for in` 循环同样在查找对象属性时遍历原型链上的所有属性。

> **注意:** `for in` 循环**不会**遍历那些 `enumerable` 设置为 `false` 的属性；比如数组的 `length` 属性。
```js
    // 修改 Object.prototype
    Object.prototype.bar = 1;

    var foo = {moo: 2};
    for(var i in foo) {
        console.log(i); // 输出两个属性：bar 和 moo
    }
```
由于不可能改变 `for in` 自身的行为，因此有必要过滤出那些不希望出现在循环体中的属性，
这可以通过 `Object.prototype` 原型上的 [`hasOwnProperty`] 函数来完成。

> **注意:** 由于 `for in` 总是要遍历整个原型链，因此如果一个对象的继承层次太深的话会影响性能。

### 使用 hasOwnProperty 过滤
```js
    // foo 变量是上例中的
    for(var i in foo) {
        if (foo.hasOwnProperty(i)) {
            console.log(i);
        }
    }
```
这个版本的代码是唯一正确的写法。由于我们使用了 `hasOwnProperty`，所以这次**只**输出 `moo`。
如果不使用 `hasOwnProperty`，则这段代码在原生对象原型（比如 `Object.prototype`）被扩展时可能会出错。

一个广泛使用的类库 [Prototype][5] 就扩展了原生的 JavaScript 对象。
因此，当这个类库被包含在页面中时，不使用 `hasOwnProperty` 过滤的 `for in` 循环难免会出问题。

> 总结

推荐**总是**使用 `hasOwnProperty`。不要对代码运行的环境做任何假设，不要假设原生对象是否已经被扩展了。

## 函数

函数是 JavaScript 中的一等对象，这意味着可以把函数像其它值一样传递。
一个常见的用法是把*匿名函数*作为回调函数传递到异步函数中。

### 函数声明
```js
    function foo() {}
```
上面的方法会在执行前被 [解析(hoisted)]，因此它存在于当前上下文的*任意*一个地方，
即使在函数定义体的上面被调用也是对的。
```js
    foo(); // 正常运行，因为 foo 在代码运行前已经被创建
    function foo() {}
```
### 函数表达式
```js
    var foo = function() {};
```
这个例子把一个*匿名*的函数赋值给变量 `foo`。
```js
    foo; // 'undefined'
    foo(); // 出错：TypeError
    var foo = function() {};
```
由于 `var` 定义了一个声明语句，对变量 `foo` 的解析是在代码运行之前，因此 `foo` 变量在代码运行时已经被定义过了。

但是由于赋值语句只在运行时执行，因此在相应代码执行之前， `foo` 的值缺省为 [undefined]。

### 函数名赋值表达式

另外一个特殊的情况是将命名函数赋值给一个变量。
```js
    var foo = function bar() {
        bar(); // 正常运行
    }
    bar(); // 出错：ReferenceError
```
`bar` 函数声明外是不可见的，这是因为我们已经把函数赋值给了 `foo`；
然而在 `bar` 内部依然可见。这是由于 JavaScript 的 [命名处理]所致，
函数名在函数内*总是*可见的。

> **注意: **在 IE8 及 IE8 以下版本浏览器 bar 在外部也是可见的，是因为浏览器对命名函数赋值表达式进行了错误的解析，
> 解析成两个函数 `foo` 和 `bar`

## this 的工作原理

JavaScript 有一套完全不同于其它语言的对 `this` 的处理机制。
在**五**种不同的情况下 ，`this` 指向的各不相同。

### 全局范围内

    this;

当在全部范围内使用 `this`，它将会指向*全局*对象。

> 浏览器中运行的 JavaScript 脚本，这个全局对象是 `window`；
> 在 nodejs 环境中运行的 Javascript 脚本，这个全局对象是 `global`。

### 函数调用

    foo();

这里 `this` 也会指向*全局*对象。

> **ES5 注意:** 在严格模式下（strict mode），不存在全局变量。
> 这种情况下 `this` 将会是 `undefined`。

### 方法调用

    test.foo();

这个例子中，`this` 指向 `test` 对象。

### 调用构造函数

    new foo();

如果函数倾向于和 `new` 关键词一块使用，则我们称这个函数是 [构造函数]。
在函数内部，`this` 指向*新创建*的对象。

### 显式的设置 this
```js
    function foo(a, b, c) {}

    var bar = {};
    foo.apply(bar, [1, 2, 3]); // 数组将会被扩展，如下所示
    foo.call(bar, 1, 2, 3); // 传递到 foo 的参数是：a = 1, b = 2, c = 3
```
当使用 `Function.prototype` 上的 `call` 或者 `apply` 方法时，函数内的 `this` 将会被
**显式设置**为函数调用的第一个参数。

因此*函数调用*的规则在上例中已经不适用了，在`foo` 函数内 `this` 被设置成了 `bar`。

> **注意:** 在对象的字面声明语法中，`this` **不能**用来指向对象本身。
> 因此 `var obj = {me: this}` 中的 `me` 不会指向 `obj`，因为 `this` 只可能出现在上述的五种情况中。
> 这个例子中，如果是在浏览器中运行，`obj.me` 等于 `window` 对象。

### 常见误解

尽管大部分的情况都说的过去，不过第一个规则（这里指的应该是第二个规则，也就是直接调用函数时，`this` 指向全局对象）
被认为是 JavaScript 语言另一个错误设计的地方，因为它**从来**就没有实际的用途。
```js
    Foo.method = function() {
        function test() {
            // this 将会被设置为全局对象（译者注：浏览器环境中也就是 window 对象）
        }
        test();
    };
```
一个常见的误解是 `test` 中的 `this` 将会指向 `Foo` 对象，实际上**不是**这样子的。

为了在 `test` 中获取对 `Foo` 对象的引用，我们需要在 `method` 函数内部创建一个局部变量指向 `Foo` 对象。
```js
    Foo.method = function() {
        var that = this;
        function test() {
            // 使用 that 来指向 Foo 对象
        }
        test();
    };
```
`that` 只是我们随意起的名字，不过这个名字被广泛的用来指向外部的 `this` 对象。
在 [闭包]一节，我们可以看到 `that` 可以作为参数传递。

### 方法的赋值

另一个看起来奇怪的地方是函数别名，也就是将一个方法**赋值**给一个变量。
```js
    var test = someObject.methodTest;
    test();
```
上例中，`test` 就像一个普通的函数被调用；因此，函数内的 `this` 将不再被指向到 `someObject` 对象。

虽然 `this` 的晚绑定特性似乎并不友好，但这确实是[基于原型继承]赖以生存的土壤。
```js
    function Foo() {}
    Foo.prototype.method = function() {};

    function Bar() {}
    Bar.prototype = Foo.prototype;

    new Bar().method();
```
当 `method` 被调用时，`this` 将会指向 `Bar` 的实例对象。

## call 和 apply 和 bind

### 1.call 和 apply

每个函数都会继承来自 Function.prototype 的方法 call,apply 和 bind 就是其中的方法。
可将一个函数的对象上下文从初始的上下文改变为第一个传入的实参指定的新对象,也就是改变 this 的指向。

call:call([thisObject[,arg1 [,arg2 [,...,argn]]]])
apply:apply([thisObj [,argArray] ]);

#### 1.1 几个注意点：

1.1.1 首先它是函数的方法，除了函数，别的对象无法调用此方法

1.2.2 我们来看看第一个参数可以传入什么？

```javascript
function Student(){
console.log(this);
};
var hanmeimei={
name:"hanmeimei";
}
Student.call();
Student.call(this);
Student.call(hanmeimei);
Student.call(1);
Student.call("abc");
Student.call(true);
Student.call(undefined);
Student.call(null);
```

- 空值：Student.call();//lilei，this 会指向 window,window.name="lilei";
- this：Student.call(this);//lilei，this 没有明确的对象还是会指向 window,window.name="lilei";
- 对象：Student.call(hanmeimei);//hanmeimei,this 指向对象 hanmeimei
- 数字：Student.call(1)//this：对应的构造函数 Number 的实例
- 字符串：Student.call("abc")//this：对应的构造函数 String 的实例
- 布尔：Student.call(true);//this：对应的构造函数 Bollean 的实例
- undefined：Student.call(undefined)//this 指向 window
- null：Student.call(null)//this 指向 window

1.2.3 我们来看看其余参数可以传入什么？

```javascript
function Student(age){
console.log(this.name,age);
};
var hanmeimei={
name:"hanmeimei";
}
```

其余参数就是实参传递。

`Student.call(hanmeimei,21);`就是把 21 赋值给 Student 中的形参 age;

### 2 call,apply 的作用

#### 2.1 用其他对象的方法

```javascript
var lilei={
name:"lilei",
sing:function(){console.log(this.name);}
}
var hanmeimei={
name:"hanmeimei";
}
lilei.sing.call(hanmeimei);//hanmeimei
```

```
var arr=[1,343,42,12];
console.log(Math.max.apply(null,arr));
console.log(Math.max(11,2,89,100));
```

```javascript
Array.prototype.slice.call(arguments); //把传入的参数转化为数组，然后使用数组的api
```

#### 2.2 调用匿名函数

```javascript
var lilei = {
  name: "lilei",
  age: 20,
}(() => {
  console.log(this.name);
}).call(lilei); //lilei
```

3.用来解耦，实现父类构造函数的继承

```javascript
function Class(klass,name){
this.klass=klass;
this.name=name;
}
function Student(klass,name){
Class.call(this,klass,name);//=>Class.klass=klass;Class.name=name;
this.sing=function(){console.log(我是${this.klass}班的${this.name})};
}
var lilei=new Student(11,"lilei");
lilei.sing();//我是11班lilei
```

解耦:相互独立，互不影响。传统的操作是循环遍历赋值，使用 call 和 apply 之后可以轻松解决。

### 3 bind 的作用

#### 3.1 永久绑定

```javascript
function Score(math,English,chinese){
console.log(`${this.name}总得分为:${math+English+chinese}分`);
};

Score.bind({name:"lilei"});
Score(80,90,100);//lilei总得分为270
Score(70,90,80);//lilei总得分为240

Score.bind({name:"lilei"}，90);//绑定math=90
Score(90,100);//lilei总得分为280
Score(90,80);//lilei总得分为260
```

#### 3.2 拷贝构造函数

因为 bind 绑定返回的是一个函数，call 和 apply 是直接调用函数，所以可以实现拷贝函数的功能。

```javascript
function Klass(name, age) {
  this.name = name;
  this.age = age;
}
var Student = Kclass.bind({});
var hanmeimei = new Student("hanmeimei");
console.log(hanmeimei.name); //hanmeimei
console.log(hanmeimei instanceof Klass); //true
```

这里的 Student 成为 bound Klass

#### 3.3 修改匿名函数 this 的指向

ex1:

```javascript
Array.prototype.multiply = function () {
  this.forEach(
    function (elem, index) {
      //this->arr
      this.push(elem * elem);
    }.bind(this)
  ); //绑定this->arr,如果不绑定会指向window
  return this;
};
var arr = [1, 2, 3, 4];
console.log(arr.multiply()); //[1,2,3,4,1,4,9,16]
```

ex2:

```javascript
var user = {
  name: "hansu",
  sing: function () {
    console.log(this.name);
    return function () {
      console.log(this.name);
    }.bind(this);
  },
};
var f = user.sing();
f(); //hansu hansu
```

当我们想要永久修改一个函数的 this 指向，且该函数还未调用时可以用 bind

### 4 区别

|          |      call       |    apply     |      bind       |
| :------: | :-------------: | :----------: | :-------------: |
| 传入参数 | (对象,单个参数) | (对象,数组)  | (对象,单个参数) |
| 绑定时效 |      一次       |     一次     |      永久       |
|  返回值  |  函数执行结果   | 函数执行结果 |      函数       |
|   用法   |   函数.call()   | 函数.apply() |   函数.bind()   |


## 闭包和引用

闭包是 JavaScript 一个非常重要的特性，这意味着当前作用域**总是**能够访问外部作用域中的变量。
因为 [函数] 是 JavaScript 中唯一拥有自身作用域的结构，因此闭包的创建依赖于函数。

> 译者注：ES2015 中增加了块级作用域。

### 模拟私有变量
```js
    function Counter(start) {
        var count = start;
        return {
            increment: function() {
                count++;
            },

            get: function() {
                return count;
            }
        }
    }

    var foo = Counter(4);
    foo.increment();
    foo.get(); // 5
```
这里，`Counter` 函数返回两个闭包，函数 `increment` 和函数 `get`。 这两个函数都维持着
对外部作用域 `Counter` 的引用，因此总可以访问此作用域内定义的变量 `count`。

### 私有变量

因为 JavaScript 中不可以对作用域进行引用或赋值，因此没有办法在外部访问 `count` 变量。
唯一的途径就是通过那两个闭包。
```js
    var foo = new Counter(4);
    foo.hack = function() {
        count = 1337;
    };
```
上面的代码**不会**改变定义在 `Counter` 作用域中的 `count` 变量的值，因为 `foo.hack` 没有
定义在那个**作用域**内。它将会创建或者覆盖*全局*变量 `count`。

### 循环中的闭包

一个常见的错误出现在循环中使用闭包，假设我们需要在每次循环中调用循环序号
```js
    for(var i = 0; i < 10; i++) {
        setTimeout(function() {
            console.log(i);
        }, 1000);
    }
```
上面的代码不会输出数字 `0` 到 `9`，而是会输出数字 `10` 十次。

当 `console.log` 被调用的时候，*匿名*函数保持对外部变量 `i` 的引用，此时 `for`循环已经结束， `i` 的值被修改成了 `10`。

为了得到想要的结果，需要在每次循环中创建变量 `i` 的**拷贝**。

### 避免引用错误

为了正确的获得循环序号，最好使用 [匿名包装器]（其实就是我们通常说的自执行匿名函数）。
```js
    for(var i = 0; i < 10; i++) {
        (function(e) {
            setTimeout(function() {
                console.log(e);
            }, 1000);
        })(i);
    }
```
外部的匿名函数会立即执行，并把 `i` 作为它的参数，此时函数内 `e` 变量就拥有了 `i` 的一个拷贝。

当传递给 `setTimeout` 的匿名函数执行时，它就拥有了对 `e` 的引用，而这个值是**不会**被循环改变的。

有另一个方法完成同样的工作，那就是从匿名包装器中返回一个函数。这和上面的代码效果一样。
```js
    for(var i = 0; i < 10; i++) {
        setTimeout((function(e) {
            return function() {
                console.log(e);
            };
        })(i), 1000);
    }
```
## arguments 对象

JavaScript 中每个函数内都能访问一个特别变量 `arguments`。这个变量维护着所有传递到这个函数中的参数列表。

> **注意:** 由于 `arguments` 已经被定义为函数内的一个变量。
> 因此通过 `var` 关键字定义 `arguments` 或者将 `arguments` 声明为一个形式参数，
> 都将导致原生的 `arguments` 不会被创建。

`arguments` 变量**不是**一个数组（`Array`）。
尽管在语法上它有数组相关的属性 `length`，但它不从 `Array.prototype` 继承，实际上它是一个对象（`Object`）。

因此，无法对 `arguments` 变量使用标准的数组方法，比如 `push`、`pop` 或者 `slice`。
虽然使用 `for` 循环遍历也是可以的，但是为了更好的使用数组方法，最好把它转化为一个真正的数组。

### 转化为数组

下面的代码将会创建一个新的数组，包含所有 `arguments` 对象中的元素。
```js
    Array.prototype.slice.call(arguments);
```
这个转化比较**慢**，在性能不好的代码中**不推荐**这种做法。

### 传递参数

下面是将参数从一个函数传递到另一个函数的推荐做法。
```js
    function foo() {
        bar.apply(null, arguments);
    }
    function bar(a, b, c) {
        // 干活
    }
```
另一个技巧是同时使用 `call` 和 `apply`，创建一个快速的解绑定包装器。
```js
    function Foo() {}

    Foo.prototype.method = function(a, b, c) {
        console.log(this, a, b, c);
    };

    // 创建一个解绑定的 "method"
    // 输入参数为: this, arg1, arg2...argN
    Foo.method = function() {

        // 结果: Foo.prototype.method.call(this, arg1, arg2... argN)
        Function.call.apply(Foo.prototype.method, arguments);
    };
```
**上面的 `Foo.method` 函数和下面代码的效果是一样的:
```js
Foo.method = function() {
var args = Array.prototype.slice.call(arguments);
Foo.prototype.method.apply(args[0], args.slice(1));
};
```
### 自动更新

`arguments` 对象为其内部属性以及函数形式参数创建 _getter_ 和 _setter_ 方法。

因此，改变形参的值会影响到 `arguments` 对象的值，反之亦然。
```js
    function foo(a, b, c) {
        arguments[0] = 2;
        a; // 2

        b = 4;
        arguments[1]; // 4

        var d = c;
        d = 9;
        c; // 3
    }
    foo(1, 2, 3);
```
### 性能真相

不管它是否有被使用，`arguments` 对象总会被创建，除了两个特殊情况 - 作为局部变量声明和作为形式参数。

`arguments` 的 _getters_ 和 _setters_ 方法总会被创建；因此使用 `arguments` 对性能不会有什么影响。
除非是需要对 `arguments` 对象的属性进行多次访问。

> **ES5 提示:** 这些 _getters_ 和 _setters_ 在严格模式下（strict mode）不会被创建。

在 [MDC][9] 中对 `strict mode` 模式下 `arguments` 的描述有助于我们的理解，请看下面代码：
```js
    // 阐述在 ES5 的严格模式下 `arguments` 的特性
    function f(a) {
      "use strict";
      a = 42;
      return [a, arguments[0]];
    }
    var pair = f(17);
    console.assert(pair[0] === 42);
    console.assert(pair[1] === 17);
```
然而，的确有一种情况会显著的影响现代 JavaScript 引擎的性能。这就是使用 `arguments.callee`。
```js
    function foo() {
        arguments.callee; // 使用这个函数对象
        arguments.callee.caller; // 以及这个函数对象的调用者
    }

    function bigLoop() {
        for(var i = 0; i < 100000; i++) {
            foo(); // 通常情况会作为内联函数...
        }
    }
```
上面代码中，`foo` 不再是一个单纯的内联函数 [inlining][8]（这里指的是解析器可以做内联处理），
因为它需要知道它自己和它的调用者。
这不仅抵消了内联函数带来的性能提升，而且破坏了封装，因此现在函数可能要依赖于特定的上下文。

因此**强烈**建议大家**不要**使用 `arguments.callee` 和它的属性。

> **ES5 提示:** 在严格模式下，`arguments.callee` 会报错 `TypeError`，因为它已经被废除了。

## 构造函数

JavaScript 中的构造函数和其它语言中的构造函数是不同的。
通过 `new` 关键字方式调用的函数都被认为是构造函数。

在构造函数内部 - 也就是被调用的函数内 - `this` 指向新创建的对象 `Object`。
这个**新创建**的对象的 [`prototype`] 被指向到构造函数的 `prototype`。

如果被调用的函数没有显式的 `return` 表达式，则隐式的会返回 `this` 对象 - 也就是新创建的对象。
```js
    function Foo() {
        this.bla = 1;
    }

    Foo.prototype.test = function() {
        console.log(this.bla);
    };

    var test = new Foo();
```
上面代码把 `Foo` 作为构造函数调用，并设置新创建对象的 `prototype` 为 `Foo.prototype`。

显式的 `return` 表达式将会影响返回结果，但**仅限**于返回的是一个对象。
```js
    function Bar() {
        return 2;
    }
    new Bar(); // 返回新创建的对象

    function Test() {
        this.value = 2;

        return {
            foo: 1
        };
    }
    new Test(); // 返回的对象
```
`new Bar()` 返回的是新创建的对象，而不是数字的字面值 2。
因此 `new Bar().constructor === Bar`，但是如果返回的是数字对象，结果就不同了，如下所示
```js
function Bar() {
return new Number(2);
}
new Bar().constructor === Number
```
这里得到的 `new Test()`是函数返回的对象，而不是通过`new`关键字新创建的对象，因此：
```js
    (new Test()).value === undefined
    (new Test()).foo === 1
```
如果 `new` 被遗漏了，则函数**不会**返回新创建的对象。
```js
    function Foo() {
        this.bla = 1; // 获取设置全局参数
    }
    Foo(); // undefined
```
虽然上例在有些情况下也能正常运行，但是由于 JavaScript 中 [`this`]的工作原理，
这里的 `this` 指向*全局对象*。

## 工厂模式

为了不使用 `new` 关键字，构造函数必须显式的返回一个值。
```js
    function Bar() {
        var value = 1;
        return {
            method: function() {
                return value;
            }
        }
    }
    Bar.prototype = {
        foo: function() {}
    };

    new Bar();
    Bar();
```
上面两种对 `Bar` 函数的调用返回的值完全相同，一个新创建的拥有 `method` 属性的对象被返回，
其实这里创建了一个[闭包]。

还需要注意， `new Bar()` 并**不会**改变返回对象的原型（也就是返回对象的原型不会指向 `Bar.prototype`）。
因为构造函数的原型会被指向到刚刚创建的新对象，而这里的 `Bar` 没有把这个新对象返回（而是返回了一个包含 `method` 属性的自定义对象）。

在上面的例子中，使用或者不使用 `new` 关键字没有功能性的区别。

上面两种方式创建的对象不能访问 `Bar` 原型链上的属性，如下所示：
```js
var bar1 = new Bar();
typeof(bar1.method); // "function"
typeof(bar1.foo); // "undefined"
var bar2 = Bar();
typeof(bar2.method); // "function"
typeof(bar2.foo); // "undefined"
```
### 通过工厂模式创建新对象

我们常听到的一条忠告是**不要**使用 `new` 关键字来调用函数，因为如果忘记使用它就会导致错误。

为了创建新对象，我们可以创建一个工厂方法，并且在方法内构造一个新对象。
```js
    function Foo() {
        var obj = {};
        obj.value = 'blub';

        var private = 2;
        obj.someMethod = function(value) {
            this.value = value;
        }

        obj.getPrivate = function() {
            return private;
        }
        return obj;
    }
```
虽然上面的方式比起 `new` 的调用方式不容易出错，并且可以充分利用[私有变量]带来的便利，
但是随之而来的是一些不好的地方。

1.  会占用更多的内存，因为新创建的对象**不能**共享原型上的方法。
2.  为了实现继承，工厂方法需要从另外一个对象拷贝所有属性，或者把一个对象作为新创建对象的原型。
3.  放弃原型链仅仅是因为防止遗漏 `new` 带来的问题，这似乎和语言本身的思想相违背。

> 总结

虽然遗漏 `new` 关键字可能会导致问题，但这并**不是**放弃使用原型链的借口。
最终使用哪种方式取决于应用程序的需求，选择一种代码书写风格并**坚持**下去才是最重要的。

## 作用域与命名空间

尽管 JavaScript 支持一对花括号创建的代码段，但是并不支持块级作用域；
而仅仅支持 _函数作用域_。
```js
    function test() { // 一个作用域
        for(var i = 0; i < 10; i++) { // 不是一个作用域
            // count
        }
        console.log(i); // 10
    }
```
> **注意:** 如果不是在赋值语句中，而是在 return 表达式或者函数参数中，`{...}` 将会作为代码段解析，
> 而不是作为对象的字面语法解析。如果考虑到 [自动分号插入]，这可能会导致一些不易察觉的错误。

如果 `return` 对象的左括号和 `return` 不在一行上就会出错。
// 译者注：下面输出 undefined
```js
function add(a, b) {
return
a + b;
}
console.log(add(1, 2));
```
JavaScript 中没有显式的命名空间定义，这就意味着所有对象都定义在一个*全局共享*的命名空间下面。

每次引用一个变量，JavaScript 会向上遍历整个作用域直到找到这个变量为止。
如果到达全局作用域但是这个变量仍未找到，则会抛出 `ReferenceError` 异常。

### 隐式的全局变量
```js
    // 脚本 A
    foo = '42';

    // 脚本 B
    var foo = '42'
```
上面两段脚本效果**不同**。脚本 A 在*全局*作用域内定义了变量 `foo`，而脚本 B 在*当前*作用域内定义变量 `foo`。

再次强调，上面的效果**完全不同**，不使用 `var` 声明变量将会导致隐式的全局变量产生。
```js
    // 全局作用域
    var foo = 42;
    function test() {
        // 局部作用域
        foo = 21;
    }
    test();
    foo; // 21
```
在函数 `test` 内不使用 `var` 关键字声明 `foo` 变量将会覆盖外部的同名变量。
起初这看起来并不是大问题，但是当有成千上万行代码时，不使用 `var` 声明变量将会带来难以跟踪的 BUG。
```js
    // 全局作用域
    var items = [/* 数组 */];
    for(var i = 0; i < 10; i++) {
        subLoop();
    }

    function subLoop() {
        // subLoop 函数作用域
        for(i = 0; i < 10; i++) { // 没有使用 var 声明变量
            // 干活
        }
    }
```
外部循环在第一次调用 `subLoop` 之后就会终止，因为 `subLoop` 覆盖了全局变量 `i`。
在第二个 `for` 循环中使用 `var` 声明变量可以避免这种错误。
声明变量时**绝对不要**遗漏 `var` 关键字，除非这就是*期望*的影响外部作用域的行为。

### 局部变量

JavaScript 中局部变量只可能通过两种方式声明，一个是作为[函数]参数，另一个是通过 `var` 关键字声明。
```js
    // 全局变量
    var foo = 1;
    var bar = 2;
    var i = 2;

    function test(i) {
        // 函数 test 内的局部作用域
        i = 5;

        var foo = 3;
        bar = 4;
    }
    test(10);
```
`foo` 和 `i` 是函数 `test` 内的局部变量，而对 `bar` 的赋值将会覆盖全局作用域内的同名变量。

### 变量声明提升（Hoisting）

JavaScript 会**提升**变量声明。这意味着 `var` 表达式和 `function` 声明都将会被提升到当前作用域的顶部。
```js
    bar();
    var bar = function() {};
    var someValue = 42;

    test();
    function test(data) {
        if (false) {
            goo = 1;

        } else {
            var goo = 2;
        }
        for(var i = 0; i < 100; i++) {
            var e = data[i];
        }
    }
```
上面代码在运行之前将会被转化。JavaScript 将会把 `var` 表达式和 `function` 声明提升到当前作用域的顶部。
```js
    // var 表达式被移动到这里
    var bar, someValue; // 缺省值是 'undefined'

    // 函数声明也会提升
    function test(data) {
        var goo, i, e; // 没有块级作用域，这些变量被移动到函数顶部
        if (false) {
            goo = 1;

        } else {
            goo = 2;
        }
        for(i = 0; i < 100; i++) {
            e = data[i];
        }
    }

    bar(); // 出错：TypeError，因为 bar 依然是 'undefined'
    someValue = 42; // 赋值语句不会被提升规则（hoisting）影响
    bar = function() {};

    test();
```
没有块级作用域不仅导致 `var` 表达式被从循环内移到外部，而且使一些 `if` 表达式更难看懂。

在原来代码中，`if` 表达式看起来修改了*全局变量* `goo`，实际上在提升规则被应用后，却是在修改*局部变量*。

如果没有提升规则（hoisting）的知识，下面的代码看起来会抛出异常 `ReferenceError`。
```js
    // 检查 SomeImportantThing 是否已经被初始化
    if (!SomeImportantThing) {
        var SomeImportantThing = {};
    }
```
实际上，上面的代码正常运行，因为 `var` 表达式会被提升到*全局作用域*的顶部。
```js
    var SomeImportantThing;

    // 其它一些代码，可能会初始化 SomeImportantThing，也可能不会

    // 检查是否已经被初始化
    if (!SomeImportantThing) {
        SomeImportantThing = {};
    }
```
在 Nettuts+ 网站有一篇介绍 hoisting 的[文章][10]，其中的代码很有启发性。
```js
    // 译者注：来自 Nettuts+ 的一段代码，生动的阐述了 JavaScript 中变量声明提升规则
    var myvar = 'my value';

    (function() {
    	alert(myvar); // undefined
    	var myvar = 'local value';
    })();
```
### 名称解析顺序

JavaScript 中的所有作用域，包括*全局作用域*，都有一个特别的名称 [`this`] 指向当前对象。

函数作用域内也有默认的变量 [`arguments`]，其中包含了传递到函数中的参数。

比如，当访问函数内的 `foo` 变量时，JavaScript 会按照下面顺序查找：

1.  当前作用域内是否有 `var foo` 的定义。
2.  函数形式参数是否有使用 `foo` 名称的。
3.  函数自身是否叫做 `foo`。
4.  回溯到上一级作用域，然后从 **#1** 重新开始。

> **注意:** 自定义 `arguments` 参数将会阻止原生的 `arguments` 对象的创建。

### 命名空间

只有一个全局作用域导致的常见错误是命名冲突。在 JavaScript 中，这可以通过 _匿名包装器_ 轻松解决。
```js
    (function() {
        // 函数创建一个命名空间

        window.foo = function() {
            // 对外公开的函数，创建了闭包
        };

    })(); // 立即执行此匿名函数
```
匿名函数被认为是 [表达式]；因此为了可调用性，它们首先会被执行。
```js
    ( // 小括号内的函数首先被执行
    function() {}
    ) // 并且返回函数对象
    () // 调用上面的执行结果，也就是函数对象
```
有一些其他的调用函数表达式的方法，比如下面的两种方式语法不同，但是效果一模一样。
```js
    // 另外两种方式
    +function(){}();
    (function(){}());
```
> 结论

推荐使用*匿名包装器*（也就是自执行的匿名函数）来创建命名空间。这样不仅可以防止命名冲突，
而且有利于程序的模块化。

另外，使用全局变量被认为是**不好的习惯**。这样的代码容易产生错误并且维护成本较高。

## 数组

虽然在 JavaScript 中数组是对象，但是没有好的理由去使用 [`for in` 循环] 遍历数组。
相反，有一些好的理由**不去**使用 `for in` 遍历数组。

> **注意:** JavaScript 中数组**不是** _关联数组_。
> JavaScript 中只有[对象] 来管理键值的对应关系。但是关联数组是**保持**顺序的，而对象**不是**。

由于 `for in` 循环会枚举原型链上的所有属性，唯一过滤这些属性的方式是使用 [`hasOwnProperty`]函数，
因此会比普通的 `for` 循环慢上好多倍。

### 数组遍历

为了达到遍历数组的最佳性能，推荐使用经典的 `for` 循环。
```js
    var list = [1, 2, 3, 4, 5, ...... 100000000];
    for(var i = 0, l = list.length; i < l; i++) {
        console.log(list[i]);
    }
```
上面代码有一个处理，就是通过 `l = list.length` 来缓存数组的长度。

虽然 `length` 是数组的一个属性，但是在每次循环中访问它还是有性能开销。
** 可能**最新的 JavaScript 引擎在这点上做了优化，但是我们没法保证自己的代码是否运行在这些最近的引擎之上。

实际上，不使用缓存数组长度的方式比缓存版本要慢很多。

### length 属性

`length` 属性的 _getter_ 方式会简单的返回数组的长度，而 _setter_ 方式会**截断**数组。
```js
    var foo = [1, 2, 3, 4, 5, 6];
    foo.length = 3;
    foo; // [1, 2, 3]

    foo.length = 6;
    foo; // [1, 2, 3]
```
** 译者注：**
在 Firebug 中查看此时 `foo` 的值是： `[1, 2, 3, undefined, undefined, undefined]`
但是这个结果并不准确，如果你在 Chrome 的控制台查看 `foo` 的结果，你会发现是这样的： `[1, 2, 3]`
因为在 JavaScript 中 `undefined` 是一个变量，注意是变量不是关键字，因此上面两个结果的意义是完全不相同的。
```js
    // 译者注：为了验证，我们来执行下面代码，看序号 5 是否存在于 foo 中。
    5 in foo; // 不管在 Firebug 或者 Chrome 都返回 false
    foo[5] = undefined;
    5 in foo; // 不管在 Firebug 或者 Chrome 都返回 true
```
为 `length` 设置一个更小的值会截断数组，但是增大 `length` 属性值不会对数组产生影响。

> 结论

为了更好的性能，推荐使用普通的 `for` 循环并缓存数组的 `length` 属性。
使用 `for in` 遍历数组被认为是不好的代码习惯并倾向于产生错误和导致性能问题。

## Array 构造函数

由于 `Array` 的构造函数在如何处理参数时有点模棱两可，因此总是推荐使用数组的字面语法 - `[]` - 来创建数组。
```js
    [1, 2, 3]; // 结果: [1, 2, 3]
    new Array(1, 2, 3); // 结果: [1, 2, 3]

    [3]; // 结果: [3]
    new Array(3); // 结果: []
    new Array('3') // 结果: ['3']

    // 译者注：因此下面的代码将会使人很迷惑
    new Array(3, 4, 5); // 结果: [3, 4, 5]
    new Array(3) // 结果: []，此数组长度为 3
```
> 这里的模棱两可指的是数组的[两种构造函数语法]

由于只有一个参数传递到构造函数中（译者注：指的是 `new Array(3);` 这种调用方式），并且这个参数是数字，构造函数会返回一个 `length` 属性被设置为此参数的空数组。
需要特别注意的是，此时只有 `length` 属性被设置，真正的数组并没有生成。

> 在 Firebug 中，你会看到 `[undefined, undefined, undefined]`，这其实是不对的。在上一节有详细的分析。
```js
    var arr = new Array(3);
    arr[1]; // undefined
    1 in arr; // false, 数组还没有生成
```
这种优先于设置数组长度属性的做法只在少数几种情况下有用，比如需要循环字符串，可以避免 `for` 循环的麻烦。
```js
    new Array(count + 1).join(stringToRepeat);
```
> **译者注：** `new Array(3).join('#')` 将会返回 `##`

> 结论

应该尽量避免使用数组构造函数创建新数组。推荐使用数组的字面语法。它们更加短小和简洁，因此增加了代码的可读性。

## 相等与比较

JavaScript 有两种方式判断两个值是否相等。

### 等于操作符

等于操作符由两个等号组成：`==`

JavaScript 是*弱类型*语言，这就意味着，等于操作符会为了比较两个值而进行**强制类型转换**。
```js
    ""           ==   "0"           // false
    0            ==   ""            // true
    0            ==   "0"           // true
    false        ==   "false"       // false
    false        ==   "0"           // true
    false        ==   undefined     // false
    false        ==   null          // false
    null         ==   undefined     // true
    " \t\r\n"    ==   0             // true
```
上面的表格展示了强制类型转换，这也是使用 `==` 被广泛认为是不好编程习惯的主要原因，
由于它的复杂转换规则，会导致难以跟踪的问题。

此外，强制类型转换也会带来性能消耗，比如一个字符串为了和一个数字进行比较，必须事先被强制转换为数字。

### 严格等于操作符

严格等于操作符由**三**个等号组成：`===`

不像普通的等于操作符，严格等于操作符**不会**进行强制类型转换。
```js
    ""           ===   "0"           // false
    0            ===   ""            // false
    0            ===   "0"           // false
    false        ===   "false"       // false
    false        ===   "0"           // false
    false        ===   undefined     // false
    false        ===   null          // false
    null         ===   undefined     // false
    " \t\r\n"    ===   0             // false
```
上面的结果更加清晰并有利于代码的分析。如果两个操作数类型不同就肯定不相等也有助于性能的提升。

### 比较对象

虽然 `==` 和 `===` 操作符都是等于操作符，但是当其中有一个操作数为对象时，行为就不同了。
```js
    {} === {};                   // false
    new String('foo') === 'foo'; // false
    new Number(10) === 10;       // false
    var foo = {};
    foo === foo;                 // true
```
这里等于操作符比较的**不是**值是否相等，而是是否属于同一个**身份**；也就是说，只有对象的同一个实例才被认为是相等的。
这有点像 Python 中的 `is` 和 C 中的指针比较。

> **注意:**为了更直观的看到`==`和`===`的区别,可以参见[JavaScript Equality Table](http://dorey.github.io/JavaScript-Equality-Table/)

> 结论

强烈推荐使用**严格等于操作符**。如果类型需要转换，应该在比较之前[显式](#types.casting)的转换，
而不是使用语言本身复杂的强制转换规则。


### typeof 操作符

`typeof` 操作符（和 [`instanceof`](#types.instanceof) 一起）或许是 JavaScript 中最大的设计缺陷，
因为几乎不可能从它们那里得到想要的结果。

尽管 `instanceof` 还有一些极少数的应用场景，`typeof` 只有一个实际的应用（这个实际应用是用来检测一个对象是否已经定义或者是否已经赋值），
而这个应用却**不是**用来检查对象的类型。

> **注意:** 由于 `typeof` 也可以像函数的语法被调用，比如 `typeof(obj)`，但这并不是一个函数调用。
> 那两个小括号只是用来计算一个表达式的值，这个返回值会作为 `typeof` 操作符的一个操作数。
> 实际上**不存在**名为 `typeof` 的函数。

### JavaScript 类型表格
```js
    Value               Class      Type
    -------------------------------------
    "foo"               String     string
    new String("foo")   String     object
    1.2                 Number     number
    new Number(1.2)     Number     object
    true                Boolean    boolean
    new Boolean(true)   Boolean    object
    new Date()          Date       object
    new Error()         Error      object
    [1,2,3]             Array      object
    new Array(1, 2, 3)  Array      object
    new Function("")    Function   function
    /abc/g              RegExp     object (function in Nitro/V8)
    new RegExp("meow")  RegExp     object (function in Nitro/V8)
    {}                  Object     object
    new Object()        Object     object
```
上面表格中，_Type_ 一列表示 `typeof` 操作符的运算结果。可以看到，这个值在大多数情况下都返回 "object"。

_Class_ 一列表示对象的内部属性 `[[Class]]` 的值。

> **JavaScript 标准文档中定义:** `[[Class]]` 的值只可能是下面字符串中的一个：
> `Arguments`, `Array`, `Boolean`, `Date`, `Error`,
> `Function`, `JSON`, `Math`, `Number`, `Object`, `RegExp`, `String`.

为了获取对象的 `[[Class]]`，我们需要使用定义在 `Object.prototype` 上的方法 `toString`。

### 对象的类定义

JavaScript 标准文档只给出了一种获取 `[[Class]]` 值的方法，那就是使用 `Object.prototype.toString`。
```js
    function is(type, obj) {
        var clas = Object.prototype.toString.call(obj).slice(8, -1);
        return obj !== undefined && obj !== null && clas === type;
    }

    is('String', 'test'); // true
    is('String', new String('test')); // true
```
上面例子中，`Object.prototype.toString` 方法被调用，[this](#function.this) 被设置为了需要获取 `[[Class]]` 值的对象。

`Object.prototype.toString` 返回一种标准格式字符串，所以上例可以通过 `slice` 截取指定位置的字符串，如下所示：
```js
Object.prototype.toString.call([]) // "[object Array]"
Object.prototype.toString.call({}) // "[object Object]"
Object.prototype.toString.call(2) // "[object Number]"
```
> **ES5 提示:** 在 ECMAScript 5 中，为了方便，对 `null` 和 `undefined` 调用 `Object.prototype.toString` 方法，
> 其返回值由 `Object` 变成了 `Null` 和 `Undefined`。

这种变化可以从 IE8 和 Firefox 4 中看出区别，如下所示：
```js
// IE8
Object.prototype.toString.call(null) // "[object Object]"
Object.prototype.toString.call(undefined) // "[object Object]"
// Firefox 4
Object.prototype.toString.call(null) // "[object Null]"
Object.prototype.toString.call(undefined) // "[object Undefined]"
```
### 测试未定义变量
```js
    typeof foo !== 'undefined'
```
上面代码会检测 `foo` 是否已经定义；如果没有定义而直接使用会导致 `ReferenceError` 的异常。
这是 `typeof` 唯一有用的地方。

> 结论

为了检测一个对象的类型，强烈推荐使用 `Object.prototype.toString` 方法；
因为这是唯一一个可依赖的方式。正如上面表格所示，`typeof` 的一些返回值在标准文档中并未定义，
因此不同的引擎实现可能不同。

除非为了检测一个变量是否已经定义，我们应尽量避免使用 `typeof` 操作符。

## instanceof 操作符

`instanceof` 操作符用来比较两个操作数的构造函数。只有在比较自定义的对象时才有意义。
如果用来比较内置类型，将会和 [`typeof` 操作符](#types.typeof) 一样用处不大。

### 比较自定义对象
```js
    function Foo() {}
    function Bar() {}
    Bar.prototype = new Foo();

    new Bar() instanceof Bar; // true
    new Bar() instanceof Foo; // true

    // 如果仅仅设置 Bar.prototype 为函数 Foo 本身，而不是 Foo 构造函数的一个实例
    Bar.prototype = Foo;
    new Bar() instanceof Foo; // false
```
### instanceof 比较内置类型
```js
    new String('foo') instanceof String; // true
    new String('foo') instanceof Object; // true

    'foo' instanceof String; // false
    'foo' instanceof Object; // false
```
有一点需要注意，`instanceof` 用来比较属于不同 JavaScript 上下文的对象（比如，浏览器中不同的文档结构）时将会出错，
因为它们的构造函数不会是同一个对象。

> 结论

`instanceof` 操作符应该**仅仅**用来比较来自同一个 JavaScript 上下文的自定义对象。
正如 [`typeof`](#types.typeof) 操作符一样，任何其它的用法都应该是避免的。

## 类型转换

JavaScript 是*弱类型*语言，所以会在**任何**可能的情况下应用*强制类型转换*。
```js
    // 下面的比较结果是：true
    new Number(10) == 10; // Number.toString() 返回的字符串被再次转换为数字

    10 == '10';           // 字符串被转换为数字
    10 == '+10 ';         // 同上
    10 == '010';          // 同上
    isNaN(null) == false; // null 被转换为数字 0
                          // 0 当然不是一个 NaN（译者注：否定之否定）

    // 下面的比较结果是：false
    10 == 010;
    10 == '-10';
```
> **ES5 提示:** 以 `0` 开头的数字字面值会被作为八进制数字解析。
> 而在 ECMAScript 5 严格模式下，这个特性被**移除**了。

为了避免上面复杂的强制类型转换，**强烈**推荐使用[严格的等于操作符](#types.equality)。
虽然这可以避免大部分的问题，但 JavaScript 的弱类型系统仍然会导致一些其它问题。

### 内置类型的构造函数

内置类型（比如 `Number` 和 `String`）的构造函数在被调用时，使用或者不使用 `new` 的结果完全不同。
```js
    new Number(10) === 10;     // False, 对象与数字的比较
    Number(10) === 10;         // True, 数字与数字的比较
    new Number(10) + 0 === 10; // True, 由于隐式的类型转换
```
使用内置类型 `Number` 作为构造函数将会创建一个新的 `Number` 对象，
而在不使用 `new` 关键字的 `Number` 函数更像是一个数字转换器。

另外，在比较中引入对象的字面值将会导致更加复杂的强制类型转换。

最好的选择是把要比较的值**显式**的转换为三种可能的类型之一。

### 转换为字符串
```js
    '' + 10 === '10'; // true
```
将一个值加上空字符串可以轻松转换为字符串类型。

### 转换为数字
```js
    +'10' === 10; // true
```
使用**一元**的加号操作符，可以把字符串转换为数字。

字符串转换为数字的常用方法：
```js
    +'010' === 10
    Number('010') === 10
    parseInt('010', 10) === 10  // 用来转换为整数

    +'010.2' === 10.2
    Number('010.2') === 10.2
    parseInt('010.2', 10) === 10
```
### 转换为布尔型

通过使用 **否** 操作符两次，可以把一个值转换为布尔型。
```js
    !!'foo';   // true
    !!'';      // false
    !!'0';     // true
    !!'1';     // true
    !!'-1'     // true
    !!{};      // true
    !!true;    // true
```

## 其他

### 为什么不要使用 eval

`eval` 函数会在当前作用域中执行一段 JavaScript 代码字符串。
```js
    var foo = 1;
    function test() {
        var foo = 2;
        eval('foo = 3');
        return foo;
    }
    test(); // 3
    foo; // 1
```
但是 `eval` 只在被**直接**调用并且调用函数就是 `eval` 本身时，才在当前作用域中执行。
```js
    var foo = 1;
    function test() {
        var foo = 2;
        var bar = eval;
        bar('foo = 3');
        return foo;
    }
    test(); // 2
    foo; // 3
```
上面的代码等价于在全局作用域中调用 `eval`，和下面两种写法效果一样：
```js
    // 写法一：直接调用全局作用域下的 foo 变量
    var foo = 1;
    function test() {
        var foo = 2;
        window.foo = 3;
        return foo;
    }
    test(); // 2
    foo; // 3

    // 写法二：使用 call 函数修改 eval 执行的上下文为全局作用域
    var foo = 1;
    function test() {
        var foo = 2;
        eval.call(window, 'foo = 3');
        return foo;
    }
    test(); // 2
    foo; // 3
```
在**任何情况下**我们都应该避免使用 `eval` 函数。99.9% 使用 `eval` 的场景都有**不使用** `eval` 的解决方案。

### 伪装的 eval

[定时函数](#other.timeouts) `setTimeout` 和 `setInterval` 都可以接受字符串作为它们的第一个参数。
这个字符串**总是**在全局作用域中执行，因此 `eval` 在这种情况下没有被直接调用。

### 安全问题

`eval` 也存在安全问题，因为它会执行**任意**传给它的代码，
在代码字符串未知或者是来自一个不信任的源时，绝对不要使用 `eval` 函数。

> 结论

绝对不要使用 `eval`，任何使用它的代码都会在它的工作方式，性能和安全性方面受到质疑。
如果一些情况必须使用到 `eval` 才能正常工作，首先它的设计会受到质疑，这**不应该**是首选的解决方案，
一个更好的不使用 `eval` 的解决方案应该得到充分考虑并优先采用。

### undefined 和 null

JavaScript 有两个表示‘空’的值，其中比较有用的是 `undefined`。

### undefined 的值

`undefined` 是一个值为 `undefined` 的类型。

这个语言也定义了一个全局变量，它的值是 `undefined`，这个变量也被称为 `undefined`。
但是这个变量**不是**一个常量，也不是一个关键字。这意味着它的*值*可以轻易被覆盖。

> **ES5 提示:** 在 ECMAScript 5 的严格模式下，`undefined` **不再是** *可写*的了。
> 但是它的名称仍然可以被隐藏，比如定义一个函数名为 `undefined`。

下面的情况会返回 `undefined` 值：

- 访问未修改的全局变量 `undefined`。
- 由于没有定义 `return` 表达式的函数隐式返回。
- `return` 表达式没有显式的返回任何内容。
- 访问不存在的属性。
- 函数参数没有被显式的传递值。
- 任何被设置为 `undefined` 值的变量。

### 处理 undefined 值的改变

由于全局变量 `undefined` 只是保存了 `undefined` 类型实际*值*的副本，
因此对它赋新值**不会**改变类型 `undefined` 的值。

然而，为了方便其它变量和 `undefined` 做比较，我们需要事先获取类型 `undefined` 的值。

为了避免可能对 `undefined` 值的改变，一个常用的技巧是使用一个传递到[匿名包装器](#function.scopes)的额外参数。
在调用时，这个参数不会获取任何值。
```js
    var undefined = 123;
    (function(something, foo, undefined) {
        // 局部作用域里的 undefined 变量重新获得了 `undefined` 值

    })('Hello World', 42);
```
另外一种达到相同目的方法是在函数内使用变量声明。
```js
    var undefined = 123;
    (function(something, foo) {
        var undefined;
        ...

    })('Hello World', 42);
```
这里唯一的区别是，在压缩后并且函数内没有其它需要使用 `var` 声明变量的情况下，这个版本的代码会多出 4 个字节的代码。

> 这里有点绕口，其实很简单。如果此函数内没有其它需要声明的变量，那么 `var` 总共 4 个字符（包含一个空白字符）
> 就是专门为 `undefined` 变量准备的，相比上个例子多出了 4 个字节。

### null 的用处

JavaScript 中的 `undefined` 的使用场景类似于其它语言中的 _null_，实际上 JavaScript 中的 `null` 是另外一种数据类型。

它在 JavaScript 内部有一些使用场景（比如声明原型链的终结 `Foo.prototype = null`），但是大多数情况下都可以使用 `undefined` 来代替。


### 自动分号插入

尽管 JavaScript 有 C 的代码风格，但是它**不**强制要求在代码中使用分号，实际上可以省略它们。

JavaScript 不是一个没有分号的语言，恰恰相反上它需要分号来就解析源代码。
因此 JavaScript 解析器在遇到由于缺少分号导致的解析错误时，会**自动**在源代码中插入分号。
```js
    var foo = function() {
    } // 解析错误，分号丢失
    test()
```
自动插入分号，解析器重新解析。
```js
    var foo = function() {
    }; // 没有错误，解析继续
    test()
```
自动的分号插入被认为是 JavaScript 语言**最大**的设计缺陷之一，因为它*能*改变代码的行为。

### 工作原理

下面的代码没有分号，因此解析器需要自己判断需要在哪些地方插入分号。
```js
    (function(window, undefined) {
        function test(options) {
            log('testing!')

            (options.list || []).forEach(function(i) {

            })

            options.value.test(
                'long string to pass here',
                'and another long string to pass'
            )

            return
            {
                foo: function() {}
            }
        }
        window.test = test

    })(window)

    (function(window) {
        window.someLibrary = {}
    })(window)
```
下面是解析器"猜测"的结果。
```js
    (function(window, undefined) {
        function test(options) {

            // 没有插入分号，两行被合并为一行
            log('testing!')(options.list || []).forEach(function(i) {

            }); // <- 插入分号

            options.value.test(
                'long string to pass here',
                'and another long string to pass'
            ); // <- 插入分号

            return; // <- 插入分号, 改变了 return 表达式的行为
            { // 作为一个代码段处理
                foo: function() {}
            }; // <- 插入分号
        }
        window.test = test; // <- 插入分号

    // 两行又被合并了
    })(window)(function(window) {
        window.someLibrary = {}; // <- 插入分号
    })(window); //<- 插入分号
```
> **注意:** JavaScript 不能正确的处理 `return` 表达式紧跟换行符的情况，
> 虽然这不能算是自动分号插入的错误，但这确实是一种不希望的副作用。

解析器显著改变了上面代码的行为，在另外一些情况下也会做出**错误的处理**。

### 前置括号

在前置括号的情况下，解析器**不会**自动插入分号。
```js
    log('testing!')
    (options.list || []).forEach(function(i) {})
```
上面代码被解析器转换为一行。
```js
    log('testing!')(options.list || []).forEach(function(i) {})
```
`log` 函数的执行结果**极大**可能**不是**函数；这种情况下就会出现 `TypeError` 的错误，详细错误信息可能是 `undefined is not a function`。

> 结论

建议**绝对**不要省略分号，同时也提倡将花括号和相应的表达式放在一行，
对于只有一行代码的 `if` 或者 `else` 表达式，也不应该省略花括号。
这些良好的编程习惯不仅可以提到代码的一致性，而且可以防止解析器改变代码行为的错误处理。

### setTimeout 和 setInterval

由于 JavaScript 是异步的，可以使用 `setTimeout` 和 `setInterval` 来计划执行函数。

> **注意:** 定时处理**不是** ECMAScript 的标准，它们在 [DOM (文档对象模型)] 被实现。
```js
    function foo() {}
    var id = setTimeout(foo, 1000); // 返回一个大于零的数字
```
当 `setTimeout` 被调用时，它会返回一个 ID 标识并且计划在将来**大约** 1000 毫秒后调用 `foo` 函数。
`foo` 函数只会被执行**一次**。

基于 JavaScript 引擎的计时策略，以及本质上的单线程运行方式，所以其它代码的运行可能会阻塞此线程。
因此**没法确保**函数会在 `setTimeout` 指定的时刻被调用。

作为第一个参数的函数将会在*全局作用域*中执行，因此函数内的 [`this`](#function.this) 将会指向这个全局对象。
```js
    function Foo() {
        this.value = 42;
        this.method = function() {
            // this 指向全局对象
            console.log(this.value); // 输出：undefined
        };
        setTimeout(this.method, 500);
    }
    new Foo();
```
> **注意:** `setTimeout` 的第一个参数是**函数对象**，一个常犯的错误是这样的 `setTimeout(foo(), 1000)`，
> 这里回调函数是 `foo` 的**返回值**，而**不是**`foo`本身。
> 大部分情况下，这是一个潜在的错误，因为如果函数返回 `undefined`，`setTimeout` 也**不会**报错。

### setInterval 的堆调用

`setTimeout` 只会执行回调函数一次，不过 `setInterval` - 正如名字建议的 - 会每隔 `X` 毫秒执行函数一次。
但是却不鼓励使用这个函数。

当回调函数的执行被阻塞时，`setInterval` 仍然会发布更多的回调指令。在很小的定时间隔情况下，这会导致回调函数被堆积起来。
```js
    function foo(){
        // 阻塞执行 1 秒
    }
    setInterval(foo, 100);
```
上面代码中，`foo` 会执行一次随后被阻塞了一秒钟。

在 `foo` 被阻塞的时候，`setInterval` 仍然在组织将来对回调函数的调用。
因此，当第一次 `foo` 函数调用结束时，已经有 **10** 次函数调用在等待执行。

### 处理可能的阻塞调用

最简单也是最容易控制的方案，是在回调函数内部使用 `setTimeout` 函数。
```js
    function foo(){
        // 阻塞执行 1 秒
        setTimeout(foo, 100);
    }
    foo();
```
这样不仅封装了 `setTimeout` 回调函数，而且阻止了调用指令的堆积，可以有更多的控制。
`foo` 函数现在可以控制是否继续执行还是终止执行。

### 手工清空定时器

可以通过将定时时产生的 ID 标识传递给 `clearTimeout` 或者 `clearInterval` 函数来清除定时，
至于使用哪个函数取决于调用的时候使用的是 `setTimeout` 还是 `setInterval`。
```js
    var id = setTimeout(foo, 1000);
    clearTimeout(id);
```
### 清除所有定时器

由于没有内置的清除所有定时器的方法，可以采用一种暴力的方式来达到这一目的。
```js
    // 清空"所有"的定时器
    for(var i = 1; i < 1000; i++) {
        clearTimeout(i);
    }
```
可能还有些定时器不会在上面代码中被清除（如果定时器调用时返回的 ID 值大于 1000），
因此我们可以事先保存所有的定时器 ID，然后一把清除。

### 隐藏使用 eval

`setTimeout` 和 `setInterval` 也接受第一个参数为字符串的情况。
这个特性**绝对**不要使用，因为它在内部使用了 `eval`。

> **注意:** 由于定时器函数不是 ECMAScript 的标准，如何解析字符串参数在不同的 JavaScript 引擎实现中可能不同。
> 事实上，微软的 JScript 会使用 `Function` 构造函数来代替 `eval` 的使用。
```js
    function foo() {
        // 将会被调用
    }

    function bar() {
        function foo() {
            // 不会被调用
        }
        setTimeout('foo()', 1000);
    }
    bar();
```
由于 `eval` 在这种情况下不是被[直接](#core.eval)调用，因此传递到 `setTimeout` 的字符串会到*全局作用域*中执行；
因此，上面的回调函数使用的不是定义在 `bar` 作用域中的局部变量 `foo`。

建议**不要**在调用定时器函数时，为了向回调函数传递参数而使用字符串的形式。
```js
    function foo(a, b, c) {}

    // 不要这样做
    setTimeout('foo(1,2, 3)', 1000)

    // 可以使用匿名函数完成相同功能
    setTimeout(function() {
        foo(1, 2, 3);
    }, 1000)
```
> **注意:** 虽然也可以使用这样的语法 `setTimeout(foo, 1000, 1, 2, 3)`，
> 但是不推荐这么做，因为在使用对象的[属性方法](#function.this)时可能会出错。
> （**译者注：**这里说的是属性方法内，`this` 的指向错误）

> 结论

**绝对不要**使用字符串作为 `setTimeout` 或者 `setInterval` 的第一个参数，
这么写的代码明显质量很差。当需要向回调函数传递参数时，可以创建一个*匿名函数*，在函数内执行真实的回调函数。

另外，应该避免使用 `setInterval`，因为它的定时执行不会被 JavaScript 阻塞。



